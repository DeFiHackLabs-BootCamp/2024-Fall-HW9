// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import {Test, console} from "forge-std/Test.sol";
import {IERC20} from "../src/interfaces/IERC20.sol";
import {ITroveManager} from "../src/interfaces/ITroveManager.sol";
import {IBorrowerOperations} from "../src/interfaces/IBorrowerOperations.sol";
import {IPrismaCore} from "../src/interfaces/IPrismaCore.sol";
import {ILiquidationManager} from "../src/interfaces/ILiquidationManager.sol";
import {IStabilityPool} from "../src/interfaces/IStabilityPool.sol";
import {IPriceFeed} from "../src/interfaces/IPriceFeed.sol";
import {IWstETH} from "../src/interfaces/IWstETH.sol";

contract ExploitBaseTest is Test {
    // Token contracts
    IERC20 public stETH = IERC20(0xae7ab96520DE3A18E5e111B5EaAb095312D7fE84);
    IWstETH public wstEth = IWstETH(0x7f39C581F595B53c5cb19bD0b3f8dA6c935E2Ca0);
    
    // Protocol contracts
    ITroveManager public wstEthTrove = ITroveManager(0x1CC79f3F47BfC060b6F761FcD1afC6D399a968B6);
    IBorrowerOperations public borrowerOperations = IBorrowerOperations(0x72c590349535AD52e6953744cb2A36B409542719);
    IStabilityPool public stabilityPool = IStabilityPool(0xed8B26D99834540C5013701bB3715faFD39993Ba);
    ILiquidationManager public liquidationManager = ILiquidationManager(0x5de309dfd7f94e9e2A18Cb6bA61CA305aBF8e9E2);
    IPrismaCore public prismaCore = IPrismaCore(0x5d17eA085F2FF5da3e6979D5d26F1dBaB664ccf8);

    // Test accounts
    address[3] public poorGuys;
    address public attacker = makeAddr("Attacker");

    modifier validation() {
        vm.startPrank(attacker);
        _;
        vm.stopPrank();

        (,, uint256 price) = wstEthTrove.getEntireSystemBalances();
        uint256 ICR = wstEthTrove.getCurrentICR(poorGuys[1], price);
        assertEq(ICR, type(uint256).max);
    }

    function setUp() public {
        uint256 blockNumber = 20526418;
        vm.createSelectFork("https://rpc.ankr.com/eth", blockNumber);

        // Setup attacker
        vm.startPrank(attacker);
        deal(attacker, 15001 ether);
        (bool success, ) = payable(address(stETH)).call{value: 15000 ether}("");
        require(success, "Failed to send stETH to attacker");
        uint256 stEthBalance = stETH.balanceOf(attacker);
        stETH.approve(address(wstEth), type(uint256).max);
        wstEth.wrap(stEthBalance);

        // Setup poor guys
        poorGuys[0] = makeAddr("Poor Guy 1");
        poorGuys[1] = makeAddr("Poor Guy 2");
        for (uint256 i = 0; i < 2; i++) {
            wstEth.transfer(poorGuys[i], 1 ether);
        }
        
        // Setup troves
        (,, uint256 price) = wstEthTrove.getEntireSystemBalances();
        _updatePrice(price * 11 / 10);
        
        vm.startPrank(poorGuys[0]);
        wstEth.approve(address(borrowerOperations), type(uint256).max);
        borrowerOperations.openTrove(
            address(wstEthTrove),
            poorGuys[0],
            1e18,
            619167537389463803,
            1799999968622422973174,
            address(0),
            address(0)
        );
        
        _updatePrice(price);
        vm.startPrank(poorGuys[1]);
        wstEth.approve(address(borrowerOperations), type(uint256).max);
        borrowerOperations.openTrove(
            address(wstEthTrove),
            poorGuys[1],
            1e18,
            743001044867356564,
            1799999968622422973174,
            address(0),
            address(0)
        );
    }

    function _updatePrice(uint256 price) private {
        IPriceFeed priceFeed = IPriceFeed(prismaCore.priceFeed());
        vm.mockCall(
            address(priceFeed),
            abi.encodeWithSelector(IPriceFeed.fetchPrice.selector),
            abi.encode(price)
        );
    }
}
